#!/usr/bin/env python3
"""
Task 11: Security Deployment Script
Automated setup for Universal RAG CMS Security System
"""

import asyncio
import os
import sys
import secrets
import subprocess
from pathlib import Path
from datetime import datetime
from cryptography.fernet import Fernet

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

print("üîí Universal RAG CMS Security Deployment")
print("=" * 60)
print(f"üìÅ Project Root: {project_root}")
print(f"üïê Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("=" * 60)


class SecurityDeployment:
    """Automated security system deployment"""
    
    def __init__(self):
        self.project_root = project_root
        self.env_file = self.project_root / ".env"
        self.env_backup = self.project_root / ".env.backup"
        
    def step(self, message: str):
        """Print deployment step"""
        print(f"\nüîß {message}")
        
    def success(self, message: str):
        """Print success message"""
        print(f"   ‚úÖ {message}")
        
    def warning(self, message: str):
        """Print warning message"""
        print(f"   ‚ö†Ô∏è {message}")
        
    def error(self, message: str):
        """Print error message"""
        print(f"   ‚ùå {message}")
    
    def check_prerequisites(self) -> bool:
        """Check if all prerequisites are met"""
        self.step("Checking prerequisites")
        
        checks = {
            "Python 3.8+": sys.version_info >= (3, 8),
            ".env file exists": self.env_file.exists(),
            "Supabase config": self._check_supabase_config(),
            "Required directories": self._check_directories()
        }
        
        all_passed = True
        for check, passed in checks.items():
            if passed:
                self.success(check)
            else:
                self.error(check)
                all_passed = False
        
        return all_passed
    
    def _check_supabase_config(self) -> bool:
        """Check Supabase configuration"""
        required_vars = ["SUPABASE_URL", "SUPABASE_SERVICE_KEY"]
        
        if not self.env_file.exists():
            return False
            
        env_content = self.env_file.read_text()
        return all(var in env_content for var in required_vars)
    
    def _check_directories(self) -> bool:
        """Check if required directories exist"""
        required_dirs = ["src", "database", "scripts"]
        return all((self.project_root / d).exists() for d in required_dirs)
    
    def generate_security_keys(self):
        """Generate and update security keys in .env"""
        self.step("Generating security keys")
        
        # Backup existing .env
        if self.env_file.exists():
            import shutil
            shutil.copy(self.env_file, self.env_backup)
            self.success(f"Backed up .env to {self.env_backup.name}")
        
        # Generate keys
        keys = {
            "ENCRYPTION_KEY": Fernet.generate_key().decode(),
            "SALT_VALUE": secrets.token_hex(16),
            "JWT_SECRET": secrets.token_urlsafe(32),
            "API_SECRET": secrets.token_urlsafe(32)
        }
        
        # Read existing content
        env_content = self.env_file.read_text() if self.env_file.exists() else ""
        
        # Add security keys
        for key, value in keys.items():
            if key not in env_content:
                env_content += f"\n{key}={value}"
                self.success(f"Generated {key}")
            else:
                self.warning(f"{key} already exists (keeping existing)")
        
        # Add security configuration
        security_config = """
# === SECURITY CONFIGURATION ===
# Generated by Security Deployment Script

# API Key Management
API_KEY_ROTATION_DAYS=90
API_KEY_LENGTH=32

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60
RATE_LIMIT_PER_HOUR=1000
BURST_LIMIT=100

# Session Management
SESSION_TIMEOUT_MINUTES=30
MAX_CONCURRENT_SESSIONS=5

# Password Policy
MIN_PASSWORD_LENGTH=12
PASSWORD_HISTORY_COUNT=5

# GDPR Compliance
DATA_RETENTION_DAYS=365
CONSENT_EXPIRY_DAYS=730

# Content Moderation
MODERATION_THRESHOLD=0.8

# Audit Settings
AUDIT_RETENTION_DAYS=2555
AUDIT_BATCH_SIZE=1000
"""
        
        # Add config if not present
        if "# === SECURITY CONFIGURATION ===" not in env_content:
            env_content += security_config
            self.success("Added security configuration")
        else:
            self.warning("Security configuration already exists")
        
        # Write updated content
        self.env_file.write_text(env_content)
        self.success("Updated .env file")
    
    def create_security_structure(self):
        """Create security module directory structure"""
        self.step("Creating security module structure")
        
        # Security directories
        security_dirs = [
            "src/security",
            "src/security/managers", 
            "src/security/utils",
            "tests/security",
            "docs/security"
        ]
        
        for directory in security_dirs:
            path = self.project_root / directory
            path.mkdir(parents=True, exist_ok=True)
            
            # Create __init__.py for Python packages
            if "src/" in directory:
                init_file = path / "__init__.py"
                if not init_file.exists():
                    init_file.write_text('"""Security module"""')
        
        self.success("Created security directory structure")
    
    async def apply_database_migration(self):
        """Apply security database migration"""
        self.step("Applying database migration")
        
        migration_file = self.project_root / "database" / "migrations" / "20240115_security_schema.sql"
        
        if not migration_file.exists():
            self.error("Migration file not found")
            return False
        
        try:
            # Import Supabase client
            from supabase import create_client
            
            supabase = create_client(
                os.environ.get("SUPABASE_URL"),
                os.environ.get("SUPABASE_SERVICE_KEY")
            )
            
            # Read migration SQL
            migration_sql = migration_file.read_text()
            
            # Execute migration (Note: This is simplified - in production you'd want proper migration handling)
            self.success("Migration file loaded")
            self.warning("Execute the migration manually in Supabase SQL Editor for now")
            self.warning(f"File: {migration_file}")
            
            return True
            
        except Exception as e:
            self.error(f"Migration failed: {str(e)}")
            return False
    
    def create_initialization_script(self):
        """Create security initialization script"""
        self.step("Creating initialization script")
        
        init_script = self.project_root / "scripts" / "init_security.py"
        init_script_content = '''#!/usr/bin/env python3
"""
Initialize Security System
Create first admin user and API key
"""

import asyncio
import os
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.security.security_manager import SecurityManager
from src.security.models import Permission, UserRole
from supabase import create_client

async def main():
    """Initialize security system"""
    print("üîí Security System Initialization")
    print("=" * 50)
    
    # Create Supabase client
    supabase = create_client(
        os.environ.get("SUPABASE_URL"),
        os.environ.get("SUPABASE_SERVICE_KEY")
    )
    
    # Initialize security manager
    security = SecurityManager(supabase)
    
    print("\nüë§ Creating admin API key...")
    admin_email = input("Enter admin email: ").strip()
    
    try:
        # Create admin API key
        admin_key_data = await security.api_keys.create_api_key(
            user_id=admin_email,
            service_name="admin_access", 
            permissions=list(Permission)
        )
        
        print("\n‚úÖ Security system initialized!")
        print("=" * 50)
        print(f"Admin Email: {admin_email}")
        print(f"API Key ID: {admin_key_data['key_id']}")
        print(f"API Key: {admin_key_data['api_key']}")
        print("=" * 50)
        print("‚ö†Ô∏è SAVE THIS API KEY SECURELY!")
        print("\nUsage:")
        print(f"Authorization: ApiKey {admin_key_data['api_key']}")
        
    except Exception as e:
        print(f"‚ùå Initialization failed: {e}")

if __name__ == "__main__":
    asyncio.run(main())
'''
        
        init_script.write_text(init_script_content)
        init_script.chmod(0o755)
        self.success("Created initialization script")
    
    def create_test_script(self):
        """Create security test script"""
        self.step("Creating test script")
        
        test_script = self.project_root / "scripts" / "test_security.py"
        test_script_content = '''#!/usr/bin/env python3
"""
Test Security Implementation
Run basic security tests
"""

import asyncio
import os
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.security.security_manager import SecurityManager
from src.security.models import Permission, UserRole, SecurityContext
from supabase import create_client

async def test_security():
    """Run security tests"""
    print("üß™ Security System Tests")
    print("=" * 50)
    
    try:
        # Initialize
        supabase = create_client(
            os.environ.get("SUPABASE_URL"),
            os.environ.get("SUPABASE_SERVICE_KEY")
        )
        security = SecurityManager(supabase)
        
        # Test 1: Input Sanitization
        print("\nüìù Test 1: Input Sanitization")
        try:
            security.sanitizer.sanitize_input("'; DROP TABLE users; --")
            print("‚ùå SQL injection not caught!")
        except ValueError:
            print("‚úÖ SQL injection blocked")
        
        # Test 2: Encryption
        print("\nüîê Test 2: Encryption")
        test_data = "sensitive information"
        encrypted = security.encryption.encrypt(test_data)
        decrypted = security.encryption.decrypt(encrypted)
        
        if test_data == decrypted:
            print("‚úÖ Encryption/decryption works")
        else:
            print("‚ùå Encryption failed")
        
        # Test 3: API Key Generation
        print("\nüîë Test 3: API Key Generation")
        key_data = await security.api_keys.create_api_key(
            user_id="test_user",
            service_name="test",
            permissions=[Permission.CONTENT_READ]
        )
        print(f"‚úÖ API key created: {key_data['key_id']}")
        
        # Test 4: Key Validation
        validation = await security.api_keys.validate_api_key(key_data["api_key"])
        if validation:
            print("‚úÖ API key validation works")
        else:
            print("‚ùå API key validation failed")
        
        print("\nüéâ All tests completed!")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")

if __name__ == "__main__":
    asyncio.run(test_security())
'''
        
        test_script.write_text(test_script_content)
        test_script.chmod(0o755)
        self.success("Created test script")
    
    def create_requirements_update(self):
        """Show required dependencies"""
        self.step("Checking dependencies")
        
        required_deps = [
            "cryptography>=41.0.0",
            "pyjwt>=2.8.0", 
            "bleach>=6.0.0",
            "python-multipart>=0.0.6",
            "langchain-openai>=0.0.5"
        ]
        
        # Check if using poetry or pip
        if (self.project_root / "pyproject.toml").exists():
            self.success("Using Poetry package management")
            print("\nüìù Add these dependencies to pyproject.toml:")
            for dep in required_deps:
                print(f"    {dep}")
            print("\nüíª Then run: poetry install")
        else:
            self.success("Using pip package management") 
            print("\nüìù Install these dependencies:")
            for dep in required_deps:
                print(f"    pip install {dep}")
    
    async def run_deployment(self):
        """Run complete deployment process"""
        self.step("Starting Security Deployment")
        
        try:
            # Step 1: Prerequisites
            if not self.check_prerequisites():
                self.error("Prerequisites not met")
                return False
            
            # Step 2: Generate keys
            self.generate_security_keys()
            
            # Step 3: Create structure
            self.create_security_structure()
            
            # Step 4: Database migration
            await self.apply_database_migration()
            
            # Step 5: Create scripts
            self.create_initialization_script()
            self.create_test_script()
            
            # Step 6: Dependencies
            self.create_requirements_update()
            
            print("\n" + "=" * 60)
            print("üéâ SECURITY DEPLOYMENT COMPLETED!")
            print("=" * 60)
            
            print("\nüìã Next Steps:")
            print("1. Install dependencies (see above)")
            print("2. Copy security implementation files to src/security/")
            print("3. Run database migration in Supabase SQL Editor")
            print("4. Initialize security: python scripts/init_security.py")
            print("5. Test system: python scripts/test_security.py")
            print("6. Update API endpoints to use SecureRAGChain")
            
            print("\nüìÅ Files Created:")
            print(f"   ‚Ä¢ {self.env_file} (updated with security keys)")
            print(f"   ‚Ä¢ src/security/ (directory structure)")
            print(f"   ‚Ä¢ database/migrations/20240115_security_schema.sql")
            print(f"   ‚Ä¢ scripts/init_security.py")
            print(f"   ‚Ä¢ scripts/test_security.py")
            
            return True
            
        except Exception as e:
            self.error(f"Deployment failed: {str(e)}")
            return False


async def main():
    """Main deployment function"""
    deployment = SecurityDeployment()
    success = await deployment.run_deployment()
    
    if success:
        print("\nüöÄ Ready to implement Task 11 Security & Compliance!")
    else:
        print("\n‚ö†Ô∏è Deployment incomplete. Please fix issues above.")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main()) 